package converter

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path"
	"reflect"
	"sort"
	"strings"

	"github.com/spf13/viper"
	"github.com/xylonx/zapx"
	"go.uber.org/zap"
)

const (
	TypeString = "string"
	TypeInt    = "int64"
	TypeFloat  = "float64"
	TypeBool   = "bool"
)

var (
	SliceTypeNotAlign = errors.New("slice type not aligned")
)

const notice = `/*
	Code generated by config2go(https://github.com/xylonx/config2go)
	DON EDIT!
*/
`

func ConvertConfigFile(src, dst, pkg string, tags []string) error {
	data := make(map[string]interface{})

	v := viper.New()

	v.SetConfigFile(src)

	if err := v.ReadInConfig(); err != nil {
		zapx.Error("read source config file failed.", zap.Error(err))
		return err
	}

	if err := v.Unmarshal(&data); err != nil {
		zapx.Error("unmarshal source config file failed.", zap.Error(err))
	}

	converter := NewMapConverter(data)

	fakeRoot, err := converter.ConvertToNodeTree()
	if err != nil {
		return err
	}

	buf := &strings.Builder{}
	buf.WriteString("package ")
	buf.WriteString(pkg)
	buf.WriteString("\n")

	buf.Write(walkTree(fakeRoot, tags).Bytes())

	// format codes
	ast, err := parser.ParseFile(token.NewFileSet(), "", buf.String(), parser.ParseComments)
	if err != nil {
		zapx.Error("parse target file failed.", zap.Error(err))
		return err
	}

	bbuf := &bytes.Buffer{}
	if err := format.Node(bbuf, token.NewFileSet(), ast); err != nil {
		zapx.Error("format target Go file failed.")
		return err
	}

	// create dst file
	if dir := path.Dir(dst); dir != "" {
		err := os.MkdirAll(dir, os.FileMode(0755))
		if err != nil {
			zapx.Error("make parent directory failed", zap.Error(err))
		}
	}
	df, err := os.Create(dst)
	if err != nil {
		zapx.Error("create target file failed", zap.Error(err))
		return err
	}

	if _, err := df.Write([]byte(notice)); err != nil {
		zapx.Error("write target file failed", zap.Error(err))
	}
	if _, err := df.Write(bbuf.Bytes()); err != nil {
		zapx.Error("write target file failed", zap.Error(err))
	}

	return nil
}

func walkTree(root *Node, tags []string) *bytes.Buffer {
	bs := &bytes.Buffer{}

	sort.Slice(root.Child, func(i, j int) bool {
		return root.Child[i].TagKey < root.Child[j].TagKey
	})

	switch root.Type { // nolint:exhaustive
	// fake root
	case reflect.Invalid:
		bs.WriteString("type Setting struct { \n")
		for i := range root.Child {
			bs.Write(walkTree(&root.Child[i], tags).Bytes())
		}
		bs.WriteString("}")

	case reflect.Map:
		bs.WriteString(fmt.Sprintf("%s	struct {\n", root.FieldName))
		for i := range root.Child {
			bs.Write(walkTree(&root.Child[i], tags).Bytes())
		}
		bs.WriteString("}")
		bs.WriteString(constructTypeTags(root.TagKey, tags))
		bs.WriteString("\n")

	case reflect.Slice:
		switch root.Child[0].Type { // nolint:exhaustive
		case reflect.Map:
			bs.WriteString(fmt.Sprintf("%s	[]struct{\n", root.FieldName))
			for i := range root.Child[0].Child {
				bs.Write(walkTree(&root.Child[0].Child[i], tags).Bytes())
			}
			bs.WriteString("}")
			bs.WriteString(constructTypeTags(root.TagKey, tags))
			bs.WriteString("\n")
		default:
			bs.WriteString(fmt.Sprintf("%s	[]%s %s\n", root.FieldName, root.Child[0].Type, constructTypeTags(root.TagKey, tags)))
		}

	default:
		bs.WriteString(fmt.Sprintf("%s	%s %s\n", root.FieldName, root.Type, constructTypeTags(root.TagKey, tags)))
	}

	return bs
}

func constructTypeTags(key string, tags []string) string {
	s := &strings.Builder{}
	s.WriteByte('`')
	for i := range tags {
		s.WriteString(fmt.Sprintf(`%s:"%s" `, tags[i], key))
	}
	s.WriteByte('`')
	return s.String()
}
