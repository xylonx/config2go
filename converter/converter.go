package converter

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path"
	"reflect"
	"sort"

	"github.com/xylonx/zapx"
	"go.uber.org/zap"
)

// TagFunc - add tags for the specific field
// for example, add mapstructure tags for all field, the AddTag is like:
//
// func mapstructureForAll (tagKey string) string {
// 		return fmt.Sprintf("`%s:\"%s\"`", tagKey, "mapstructure")
// }
type TagFunc func(tagKey string) (tags string)

var noopTagFunc TagFunc = TagFunc(func(string) string {
	return ""
})

var AppendAllFields = func(tags []string) TagFunc {
	return func(tagKey string) string {
		buf := &bytes.Buffer{}
		buf.WriteString("`")
		for _, tag := range tags {
			// ${tag}:"${tagKey}"
			buf.WriteString(tag)
			buf.WriteString(`:"`)
			buf.WriteString(tagKey)
			buf.WriteString(`" `)
		}
		buf.WriteString("`")
		return buf.String()
	}
}

var (
	ErrorSliceTypeNotAlign = errors.New("slice type not aligned")
	ErrorNilParser         = errors.New("parser can not be nil")
	ErrorUnsupportedMap    = errors.New("unsupported map type")
)

const notice = `/*
	Code generated by config2go(https://github.com/xylonx/config2go)
	DON EDIT!
*/
`

type Node struct {
	// inner node properties
	// the tag key of the node
	TagKey string
	// the struct field name
	FieldName string
	// the node type: string, bool, int64, float64, Slice, Map and so on
	Type reflect.Kind

	// sort with alphabeta
	Child []Node
}

type Converter struct {
	// Parser - using to parse data into Node AST tree
	Parser

	// AppendTags - appending tags to strcut field by its name
	AppendTags TagFunc

	// stashCodes - store the intermediate and final codes
	codes *bytes.Buffer
}

type Parser interface {
	ParseToNodeTree() (*Node, error)
}

func NewConverter(parser Parser, appendTagFunc TagFunc) *Converter {
	return &Converter{
		Parser:     parser,
		AppendTags: appendTagFunc,
	}
}

func (c *Converter) Convert(pkg, dst string) error {
	if c.Parser == nil {
		return ErrorNilParser
	}

	if c.AppendTags == nil {
		c.AppendTags = noopTagFunc
	}

	if pkg == "" {
		pkg = "config"
	}

	if c.codes == nil {
		c.codes = &bytes.Buffer{}
	}

	root, err := c.ParseToNodeTree()
	if err != nil {
		return err
	}

	// append package on the top of codes
	c.codes.WriteString("package ")
	c.codes.WriteString(pkg)
	c.codes.WriteString("\n")
	c.codes.Write(c.walkTree(root).Bytes())

	// format codes
	if err := c.formatCodes(); err != nil {
		return err
	}

	// write target file
	if dir := path.Dir(dst); dir != "" {
		err := os.MkdirAll(dir, os.FileMode(0755))
		if err != nil {
			zapx.Error("make target directory failed", zap.Error(err))
			return err
		}
	}
	tfile, err := os.Create(dst)
	if err != nil {
		zapx.Error("create target file failed", zap.Error(err))
		return err
	}

	if _, err := tfile.Write([]byte(notice)); err != nil {
		zapx.Error("write codes to target file failed", zap.Error(err))
		return err
	}
	if _, err := tfile.Write(c.codes.Bytes()); err != nil {
		zapx.Error("write codes to target file failed", zap.Error(err))
		return err
	}

	return nil
}

func (c *Converter) walkTree(root *Node) *bytes.Buffer {
	bs := &bytes.Buffer{}

	// sort key by alphabeta
	sort.Slice(root.Child, func(i, j int) bool {
		return root.Child[i].TagKey < root.Child[j].TagKey
	})

	switch root.Type { // nolint:exhaustive
	// basic type
	default:
		// ${fieldName}	${fieldType} `${tags}`
		bs.WriteString(fmt.Sprintf("%s %s %s\n", root.FieldName, root.Type, c.AppendTags(root.TagKey)))

	case reflect.Invalid:
		bs.WriteString("type Setting struct { \n")
		for i := range root.Child {
			bs.Write(c.walkTree(&root.Child[i]).Bytes())
		}
		bs.WriteString("} \n")

	case reflect.Map:
		// ${fieldName} struct {
		// 		...
		// } `${tags}`
		bs.WriteString(root.FieldName)
		bs.WriteString(" struct { \n")
		for i := range root.Child {
			bs.Write(c.walkTree(&root.Child[i]).Bytes())
		}
		bs.WriteString("} ")
		bs.WriteString(c.AppendTags(root.TagKey))
		bs.WriteString("\n")

	case reflect.Slice:
		// ${fieldName} []${innterType} {
		// 		...
		// }
		bs.WriteString(root.FieldName)
		bs.WriteString(" []")
		bs.Write(c.walkTree(&root.Child[0]).Bytes())
	}

	return bs
}

func (c *Converter) formatCodes() error {
	ast, err := parser.ParseFile(token.NewFileSet(), "", c.codes, parser.ParseComments)
	if err != nil {
		zapx.Info("parse to target file failed.", zap.Error(err))
		return err
	}

	c.codes.Reset()
	if err := format.Node(c.codes, token.NewFileSet(), ast); err != nil {
		zapx.Error("format target file failed.")
		return err
	}

	return nil
}
